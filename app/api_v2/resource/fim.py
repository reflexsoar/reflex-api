from flask_restx import Resource, Namespace, fields, inputs as xinputs

from ..utils import token_required, user_has
from .shared import ISO8601, mod_user_list

from app.api_v2.model.fim import FimRule

api = Namespace('File Integrity Monitoring', description='Package Management', path='/fim')

mod_create_fim_rule = api.model('CreateFimRule', {
    'name': fields.String(required=True, description='The rule name'),
    'organization': fields.String(required=False, description='The organization UUID'),
    'active': fields.Boolean(required=True, description='Is the rule active?', default=True),
    'description': fields.String(required=True, description='A description of why this rule exists and what it does'),
    'severity': fields.Integer(required=True, description='The rule severity', enum=[0,1,2,3,4]),
    'risk_score': fields.Integer(required=True, description='A risk score to set on alerts generated by this rule'),
    'paths': fields.List(fields.String(required=True, description='The paths to monitor')),
    'recursive': fields.Boolean(required=True, description='Should the paths be recursively monitored?', default=False),
    'file_types': fields.List(fields.String(required=True, description='The file types to monitor. Leave empty to monitor all file types')),
    'include_patterns': fields.List(fields.String(required=False, description='The file patterns to include')),
    'exclude_patterns': fields.List(fields.String(required=False, description='The file patterns to exclude')),
    'max_file_size': fields.Integer(required=True, description='The maximum file size to monitor. Default: 100Mb', default=1000000),
    'max_parallel_files': fields.Integer(required=True, description='The maximum number of files to monitor in parallel', default=5),
    'check_interval': fields.Integer(required=True, description='The interval to check for changes in seconds', default=60),
    'hashes': fields.List(fields.String(required=True, description='The hashes to monitor', enum=['md5', 'sha1', 'sha256', 'sha512'])),
    'alert': fields.Boolean(required=True, description='Should alerts be generated for this rule?'),
    'collect_additional_data': fields.Boolean(required=True, description='Should additional data be collected for this rule?')
})

mod_fim_rule_details = api.model('FimRuleDetails', {
    'uuid': fields.String(description='The rule UUID'),
    'organization': fields.String(description='The organization UUID'),
    'name': fields.String(description='The rule name'),
    'active': fields.Boolean(description='Is the rule active?', default=False),
    'description': fields.String(description='A description of why this rule exists and what it does'),
    'severity': fields.Integer(description='The rule severity', enum=[0,1,2,3,4]),
    'risk_score': fields.Integer(description='A risk score to set on alerts generated by this rule'),
    'paths': fields.List(fields.String(description='The paths to monitor'), default=[]),
    'recursive': fields.Boolean(description='Should the paths be recursively monitored?', default=False),
    'file_types': fields.List(fields.String(description='The file types to monitor. Leave empty to monitor all file types'), default=[]),
    'include_patterns': fields.List(fields.String(description='The file patterns to include'), default=[]),
    'exclude_patterns': fields.List(fields.String(description='The file patterns to exclude'), default=[]),
    'max_file_size': fields.Integer(description='The maximum file size to monitor. Default: 100Mb', default=1000000),
    'max_parallel_files': fields.Integer(description='The maximum number of files to monitor in parallel', default=5),
    'check_interval': fields.Integer(description='The interval to check for changes in seconds', default=60),
    'hashes': fields.List(fields.String(description='The hashes to monitor', enum=['md5', 'sha1', 'sha256', 'sha512'])),
    'alert': fields.Boolean(description='Should alerts be generated for this rule?'),
    'collect_additional_data': fields.Boolean(description='Should additional data be collected for this rule?'),
    'created_by': fields.Nested(mod_user_list, description='The User that Created the Rule'),
    'updated_by': fields.Nested(mod_user_list, description='The User that Last Updated the Rule'),
    'created_at': ISO8601(description='The Rule Creation Date'),
    'updated_at': ISO8601(description='The Rule Last Update Date')
})

mod_fim_rule_list = api.model('FimRuleList', {
    'rules': fields.List(fields.Nested(mod_fim_rule_details), description='The List of Rules')
})

@api.route("/<uuid>")
class FimRuleDetails(Resource):

    @api.doc(security="Bearer")
    @api.marshal_with(mod_fim_rule_details)
    @token_required
    @user_has('view_fim_rules')
    def get(self, uuid, current_user):
        api.abort(404, "Not Implemented")

    @api.doc(security="Bearer")
    @api.expect(mod_create_fim_rule)
    @api.marshal_with(mod_fim_rule_details)
    @token_required
    @user_has('update_fim_rule')
    def put(self, uuid, current_user):

        if 'organization' in api.payload:
            if current_user.is_default_org():
                rule = FimRule.get_by_uuid(uuid, organization=api.payload['organization'])
            rule = FimRule.get_by_uuid(uuid)
        else:
            rule = FimRule.get_by_uuid(uuid)
        
        if not rule:
            api.abort(404, "Rule not found")

        if 'name' in api.payload:
            existing_rule = FimRule.get_by_name(api.payload['name'], organization=rule.organization)
            if existing_rule and existing_rule.uuid != rule.uuid:
                api.abort(409, "A rule with that name already exists")
        
        rule.update(**api.payload, refresh=True)

        return rule

    @api.doc(security="Bearer")
    @token_required
    @user_has('delete_fim_rule')
    def delete(self, uuid, current_user):

        rule = FimRule.get_by_uuid(uuid)
        if not rule:
            api.abort(404, "Rule not found")

        if rule.active is True:
            api.abort(409, "Cannot delete an active rule")

        rule.delete(refresh=True)
        return {}


rule_list_parser = api.parser()

# Active Filter
rule_list_parser.add_argument('active', type=xinputs.boolean, location='args', required=False, default=None, help='Filter by active status')

# List Rules
@api.route('')
class FimRuleList(Resource):

    @api.doc(security="Bearer")
    @api.marshal_with(mod_fim_rule_list)
    @api.expect(rule_list_parser)
    @token_required
    @user_has('view_fim_rules')
    def get(self, current_user):
        """ Returns a list of all FIM rules """

        args = rule_list_parser.parse_args()

        search = FimRule.search()

        if args.active is not None:
            search = search.filter('term', active=args.active)

        rules = [r for r in search.scan()]
        return {'rules': rules}
    
    @api.doc(security="Bearer")
    @api.expect(mod_create_fim_rule)
    @api.marshal_with(mod_fim_rule_details)
    @token_required
    @user_has('create_fim_rule')
    def post(self, current_user):
        """ Creates a new FIM rule """

        organization = current_user.organization

        if 'organization' in api.payload and current_user.is_default_org():
            existing_rule = FimRule.get_by_name(api.payload['name'],
                                                organization=api.payload['organization'])
            organization = api.payload['organization']
            del api.payload['organization']
        else:
            existing_rule = FimRule.get_by_name(api.payload['name'], organization=organization)
        
        if existing_rule:
            api.abort(409, "A rule with that name already exists")

        if 'active' not in api.payload:
            api.payload['active'] = False
        
        rule = FimRule(**api.payload, organization=organization)

        rule.save(refresh=True)
        
        return rule
