from flask_restx import Resource, Namespace, fields, inputs as xinputs

from ..utils import token_required, user_has
from .shared import ISO8601, mod_user_list

from app.api_v2.model.fim import FimRule

api = Namespace('File Integrity Monitoring', description='Package Management', path='/fim')

mod_create_fim_rule = api.model('CreateFimRule', {
    'name': fields.String(required=True, description='The rule name'),
    'organization': fields.String(required=False, description='The organization UUID'),
    'active': fields.Boolean(required=True, description='Is the rule active?', default=True),
    'description': fields.String(required=True, description='A description of why this rule exists and what it does'),
    'severity': fields.Integer(required=True, description='The rule severity', enum=[0,1,2,3,4]),
    'risk_score': fields.Integer(required=True, description='A risk score to set on alerts generated by this rule'),
    'paths': fields.List(fields.String(required=True, description='The paths to monitor')),
    'recursive': fields.Boolean(required=True, description='Should the paths be recursively monitored?', default=False),
    'file_types': fields.List(fields.String(required=True, description='The file types to monitor. Leave empty to monitor all file types')),
    'include_patterns': fields.List(fields.String(required=False, description='The file patterns to include')),
    'exclude_patterns': fields.List(fields.String(required=False, description='The file patterns to exclude')),
    'max_file_size': fields.Integer(required=True, description='The maximum file size to monitor. Default: 100Mb', default=1000000),
    'max_parallel_files': fields.Integer(required=True, description='The maximum number of files to monitor in parallel', default=5),
    'check_interval': fields.Integer(required=True, description='The interval to check for changes in seconds', default=60),
    'hashes': fields.List(fields.String(required=True, description='The hashes to monitor', enum=['md5', 'sha1', 'sha256', 'sha512'])),
    'alert': fields.Boolean(required=True, description='Should alerts be generated for this rule?'),
    'collect_additional_data': fields.Boolean(required=True, description='Should additional data be collected for this rule?')
})

mod_fim_rule_details = api.model('FimRuleDetails', {
    'uuid': fields.String(description='The rule UUID'),
    'organization': fields.String(description='The organization UUID'),
    'name': fields.String(description='The rule name'),
    'active': fields.Boolean(description='Is the rule active?'),
    'description': fields.String(description='A description of why this rule exists and what it does'),
    'severity': fields.Integer(description='The rule severity', enum=[0,1,2,3,4]),
    'risk_score': fields.Integer(description='A risk score to set on alerts generated by this rule'),
    'paths': fields.List(fields.String(description='The paths to monitor'), default=[]),
    'recursive': fields.Boolean(description='Should the paths be recursively monitored?', default=False),
    'file_types': fields.List(fields.String(description='The file types to monitor. Leave empty to monitor all file types'), default=[]),
    'include_patterns': fields.List(fields.String(description='The file patterns to include'), default=[]),
    'exclude_patterns': fields.List(fields.String(description='The file patterns to exclude'), default=[]),
    'max_file_size': fields.Integer(description='The maximum file size to monitor. Default: 100Mb', default=1000000),
    'max_parallel_files': fields.Integer(description='The maximum number of files to monitor in parallel', default=5),
    'check_interval': fields.Integer(description='The interval to check for changes in seconds', default=60),
    'hashes': fields.List(fields.String(description='The hashes to monitor', enum=['md5', 'sha1', 'sha256', 'sha512'])),
    'alert': fields.Boolean(description='Should alerts be generated for this rule?'),
    'collect_additional_data': fields.Boolean(description='Should additional data be collected for this rule?'),
    'created_by': fields.Nested(mod_user_list, description='The User that Created the Rule'),
    'updated_by': fields.Nested(mod_user_list, description='The User that Last Updated the Rule'),
    'created_at': ISO8601(description='The Rule Creation Date'),
    'updated_at': ISO8601(description='The Rule Last Update Date')
})

mod_fim_rule_list = api.model('FimRuleList', {
    'rules': fields.List(fields.Nested(mod_fim_rule_details), description='The List of Rules')
})

@api.route("/<uuid>")
class FimRuleDetails(Resource):

    @api.doc(security="Bearer")
    @api.marshal_with(mod_fim_rule_details)
    @token_required
    @user_has('view_fim_rules')
    def get(self, uuid, current_user):
        api.abort(404, "Not Implemented")

    @api.doc(security="Bearer")
    @api.expect(mod_create_fim_rule)
    @api.marshal_with(mod_fim_rule_details)
    @token_required
    @user_has('edit_fim_rule')
    def put(self, uuid, current_user):
        api.abort(404, "Not Implemented")

    @api.doc(security="Bearer")
    @token_required
    @user_has('delete_fim_rule')
    def delete(self, uuid, current_user):
        api.abort(404, "Not Implemented")
        

# List Rules
@api.route('')
class FimRuleList(Resource):

    @api.doc(security="Bearer")
    @api.marshal_with(mod_fim_rule_list)
    @token_required
    @user_has('view_fim_rules')
    def get(self, current_user):
        """ Returns a list of all FIM rules """
        rules = [r for r in FimRule.search().scan()]
        return {'rules': rules}
    
    @api.doc(security="Bearer")
    @api.expect(mod_create_fim_rule)
    @api.marshal_with(mod_fim_rule_details)
    @token_required
    @user_has('create_fim_rule')
    def post(self, current_user):
        """ Creates a new FIM rule """

        organization = current_user.organization

        if 'organization' in api.payload and current_user.is_default_org():
            existing_rule = FimRule.get_by_name(api.payload['name'],
                                                organization=api.payload['organization'])
            organization = api.payload['organization']
            del api.payload['organization']
        else:
            existing_rule = FimRule.get_by_name(api.payload['name'], organization=organization)
        
        if existing_rule:
            api.abort(409, "A rule with that name already exists")
        
        rule = FimRule(**api.payload, organization=organization)

        rule.save(refresh=True)
        
        return rule
